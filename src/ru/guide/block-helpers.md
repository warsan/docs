# Блоки помощников

Помощники блоков позволяют определять настраиваемые итераторы и другие функции, которые могут вызывать переданный блок с новым контекстом.

## Основные блоки

В демонстрационных целях давайте определим вспомогательную функцию блока, которая вызывает блок, как если бы помощник не существовал.

```handlebars
<div class="entry">
  <h1>{{title}}</h1>
  <div class="body">
    {{#noop}}{{body}}{{/noop}}
  </div>
</div>
```

Помощник `noop` ​​(сокращение от «no operation») получит хэш параметров. Этот хэш параметров содержит функцию (`options.fn`), которая ведет себя как обычный скомпилированный шаблон Handlebars. В частности, функция примет контекст и вернет строку.

```js
Handlebars.registerHelper("noop", function(options) {
  return options.fn(this);
});
```

Handlebars всегда вызывает помощников с текущим контекстом как `this`, поэтому вы можете вызвать блок с помощью `this` для оценки блока в текущем контексте.

Любые помощники, определенные таким образом, будут иметь приоритет над полями, определенными в контексте. Для доступа к полю, замаскированному помощником, можно использовать ссылку на путь. В приведенном выше примере для ссылки на поле с именем `noop` ​​в объекте контекста будет использоваться:

```handlebars
{{./noop}}
```

## Базовая вариация блока

Чтобы лучше проиллюстрировать синтаксис, давайте определим другой помощник блока, который добавляет некоторую разметку к обернутому тексту.

```handlebars
<div class="entry">
  <h1>{{title}}</h1>
  <div class="body">
    {{#bold}}{{body}}{{/bold}}
  </div>
</div>
```

Помощник полужирным шрифтом добавит разметку, чтобы сделать текст жирным. Как и раньше, функция примет контекст в качестве входных данных и вернет String.

```js
Handlebars.registerHelper("bold", function(options) {
  return new Handlebars.SafeString('<div class="mybold">' + options.fn(this) + "</div>");
});
```

## Помощник `with`

Помощник `with` демонстрирует, как передать параметр вашему помощнику. Когда помощник вызывается с параметром, он вызывается с любым контекстом, в который передан шаблон.

```handlebars
<div class="entry">
  <h1>{{title}}</h1>
  {{#with story}}
    <div class="intro">{{{intro}}}</div>
    <div class="body">{{{body}}}</div>
  {{/with}}
</div>
```

Такой помощник может оказаться полезным, если раздел вашего объекта JSON содержит глубоко вложенные свойства, и вы хотите избежать повторения родительского имени. Вышеупомянутый шаблон может быть полезен с JSON, например:

```js
{
  title: "First Post",
  story: {
    intro: "Before the jump",
    body: "After the jump"
  }
}

```

Реализация такого помощника очень похожа на реализацию помощника `noop`. Помощники могут принимать параметры, и параметры оцениваются так же, как выражения, используемые непосредственно внутри блоков `{{mustache}}`.

```js
Handlebars.registerHelper("with", function(context, options) {
  return options.fn(context);
});
```

Параметры передаются помощникам в том порядке, в котором они передаются, за которым следует хэш параметров.

## Простые итераторы

Распространенный вариант использования помощников блоков - их использование для определения пользовательских итераторов. Фактически, все встроенные помощники Handlebars определяются как обычные помощники блоков Handlebars. Давайте посмотрим, как работает встроенный помощник `each`.

```handlebars
<div class="entry">
  <h1>{{title}}</h1>
  {{#with story}}
    <div class="intro">{{{intro}}}</div>
    <div class="body">{{{body}}}</div>
  {{/with}}
</div>
<div class="comments">
  {{#each comments}}
    <div class="comment">
      <h2>{{subject}}</h2>
      {{{body}}}
    </div>
  {{/each}}
</div>
```

В этом случае мы хотим вызвать блок, переданный в `each`, один раз для каждого элемента в массиве комментариев.

```js
Handlebars.registerHelper("each", function(context, options) {
  var ret = "";

  for (var i = 0, j = context.length; i < j; i++) {
    ret = ret + options.fn(context[i]);
  }

  return ret;
});
```

В этом случае мы перебираем элементы в переданном параметре, вызывая блок один раз с каждым элементом. Во время итерации мы создаем результат String, а затем возвращаем его.

Этот шаблон можно использовать для реализации более сложных итераторов. Например, давайте создадим итератор, который создает оболочку `<ul>` и помещает каждый результирующий элемент в `<li>`.

```handlebars
{{#list nav}}
  <a href="{{url}}">{{title}}</a>
{{/list}}
```

Вы можете оценить этот шаблон, используя что-то вроде этого в качестве контекста:

```js
{
  nav: [
    { url: "http://www.yehudakatz.com", title: "Кац получил свой язык" },
    { url: "http://www.sproutcore.com/block", title: "Блог SproutCore" }
  ];
}
```

Помощник похож на оригинальный помощник `each`.

```js
Handlebars.registerHelper("list", function(context, options) {
  var ret = "<ul>";

  for (var i = 0, j = context.length; i < j; i++) {
    ret = ret + "<li>" + options.fn(context[i]) + "</li>";
  }

  return ret + "</ul>";
});
```

Использование такой библиотеки, как underscore.js или библиотека времени выполнения SproutCore, может сделать это немного красивее. Например, вот как это может выглядеть при использовании библиотеки времени выполнения SproutCore:

```js
Handlebars.registerHelper("list", function(context, options) {
  return (
    "<ul>" +
    context
      .map(function(item) {
        return "<li>" + options.fn(item) + "</li>";
      })
      .join("\n") +
    "</ul>"
  );
});
```

## Условные

Другой распространенный вариант использования помощников блоков - оценка условных операторов. Как и в случае с итераторами, встроенные в Handlebars управляющие структуры if и except реализованы как обычные помощники Handlebars.

```handlebars
{{#if isActive}}
  <img src="star.gif" alt="Active">
{{/if}}
```

Структуры управления обычно не изменяют текущий контекст, вместо этого они решают, вызывать ли блок на основе некоторой переменной.

```js
Handlebars.registerHelper("if", function(conditional, options) {
  if (conditional) {
    return options.fn(this);
  }
});
```

При написании условного выражения вы часто хотите, чтобы шаблоны предоставляли блок HTML, который ваш помощник должен вставить, если условное выражение оценивается как ложное. Handlebars решает эту проблему, предоставляя общую функциональность else для блокировки помощников.

```handlebars
{{#if isActive}}
  <img src="star.gif" alt="Active">
{{else}}
  <img src="cry.gif" alt="Inactive">
{{/if}}
```

Handlebars предоставляет блок для фрагмента `else` как `options.inverse`. Вам не нужно проверять наличие фрагмента `else`: Handlebars обнаружит его автоматически и зарегистрирует функцию "noop".

```js
Handlebars.registerHelper("if", function(conditional, options) {
  if (conditional) {
    return options.fn(this);
  } else {
    return options.inverse(this);
  }
});
```

Handlebars предоставляет дополнительные метаданные для блокировки помощников, прикрепляя их как свойства хэша параметров. Продолжайте читать, чтобы увидеть больше примеров.

Условные выражения также могут быть связаны путем включения последующего вызова помощника в усы else.

```handlebars
{{#if isActive}}
  <img src="star.gif" alt="Active">
{{else if isInactive}}
  <img src="cry.gif" alt="Inactive">
{{/if}}

```

Нет необходимости использовать один и тот же помощник в последующих вызовах, помощник if может использоваться в части else, как и любой другой помощник. Когда значения помощника различны, закрывающие усы должны соответствовать имени открывающего помощника.

## Хеш-аргументы

Как и обычные помощники, помощники блоков могут принимать дополнительный хэш в качестве последнего аргумента. Давайте вернемся к помощнику `list` и дадим нам возможность добавлять любое количество необязательных атрибутов к элементу `<ul>`, который мы создадим.

```handlebars
{{#list nav id="nav-bar" class="top"}}
  <a href="{{url}}">{{title}}</a>
{{/list}}
```

Handlebars предоставляет окончательный хэш как `options.hash`. Это упрощает принятие переменного числа параметров, а также принятие необязательного хэша. Если шаблон не предоставляет хеш-аргументов, Handlebars автоматически передаст пустой объект (`{}`), поэтому вам не нужно проверять наличие хеш-аргументов.

```js
Handlebars.registerHelper("list", function(context, options) {
  var attrs = Object.keys(options.hash)
    .map(function(key) {
      return key + '="' + options.hash[key] + '"';
    })
    .join(" ");

  return (
    "<ul " +
    attrs +
    ">" +
    context
      .map(function(item) {
        return "<li>" + options.fn(item) + "</li>";
      })
      .join("\n") +
    "</ul>"
  );
});
```

Аргументы хеширования предоставляют мощный способ предложить ряд дополнительных параметров помощнику блока без сложности, вызванной позиционными аргументами.

Помощники блоков также могут вводить частные переменные в свои дочерние шаблоны. Это может быть полезно для добавления дополнительной информации, которой нет в исходных данных контекста.

Например, при итерации по списку вы можете указать текущий индекс как частную переменную.

```handlebars
{{#list array}}
  {{@index}}. {{title}}
{{/list}}
```

```js
Handlebars.registerHelper("list", function(context, options) {
  var out = "<ul>",
    data;

  if (options.data) {
    data = Handlebars.createFrame(options.data);
  }

  for (var i = 0; i < context.length; i++) {
    if (data) {
      data.index = i;
    }

    out += "<li>" + options.fn(context[i], { data: data }) + "</li>";
  }

  out += "</ul>";
  return out;
});
```

Частные переменные, предоставляемые с помощью опции `data`, доступны во всех дочерних областях.

Доступ к частным переменным, определенным в родительских областях, можно получить через патченные запросы. Для доступа к полю `index` родительского итератора можно использовать `@../index`.

Убедитесь, что вы создали новый фрейм данных в каждом помощнике, который назначает свои собственные данные. В противном случае нижестоящие помощники могут неожиданно изменить вышестоящие переменные.

Также убедитесь, что поле `data` определено, прежде чем пытаться взаимодействовать с существующим объектом данных. Поведение частной переменной компилируется условно, и некоторые шаблоны могут не создавать это поле.

## Параметры блока

Новое в Handlebars 3.0 - возможность получать именованные параметры от вспомогательных помощников.

```handlebars
{{#each users as |user userId|}}
  Id: {{userId}} Name: {{user.name}}
{{/each}}
```

В этом конкретном примере `user` будет иметь то же значение, что и текущий контекст, а `userId` будет иметь значение индекса для итерации.

Это позволяет вложенным помощникам избежать конфликтов имен, которые могут возникнуть с частными переменными.

```handlebars
{{#each users as |user userId|}}
  {{#each user.book as |book bookId|}}
    User Id: {{userId}} Book Id: {{bookId}}
  {{/each}}
{{/each}}
```

Некоторые [встроенные помощники] (builtin-helpers.html) поддерживают параметры блоков, и любой пользовательский помощник может предоставить их через поле параметров `blockParams`.

Реализует помощник, который позволяет объявления именованных переменных в данном блоке. В этом примере при рендеринге будет выводиться `1 2 3`.

Помощники могут определить количество параметров блока, на которые ссылается шаблон, через поле `options.fn.blockParams`, которое является целым числом. Это значение представляет количество параметров блока, на которые может ссылаться дочерний шаблон.  
На параметры, превышающие это число, никогда не будут ссылаться и при желании помощник может их безопасно опустить. Это необязательно, и любые дополнительные параметры, переданные в шаблон, будут игнорироваться.

## Необработанные блоки

Необработанные блоки доступны для шаблонов, требующих обработки необработанных блоков усов.

<ExamplePart examplePage="/examples/raw-blocks.md" show="template"/>

```handlebars
{{{{raw-helper}}}}
  {{bar}}
{{{{/raw-helper}}}}
```

выполнит вспомогательный raw-helper без интерпретации содержимого.

```js
Handlebars.registerHelper("raw-helper", function(options) {
  return options.fn();
});
```

will render

```
{{bar}}
```
